#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
fn f(x: f64) -> f64 {
    4.0 / (1.0 + x.powf(2.0))
}
fn g(x: f64) -> f64 {
    x.powf(4.0) + x.powf(2.0) + 1.0
}
fn h(x: f64) -> f64 {
    std::f64::consts::E.powf(-x.powf(2.0))
}
fn j(x: f64) -> f64 {
    x.powf(2.0).sin()
}
struct Function {
    f: fn(f64) -> f64,
    identifier: &'static str,
    a: f64,
    b: f64,
    n: u8,
    k: u8,
}
#[automatically_derived]
impl ::core::clone::Clone for Function {
    #[inline]
    fn clone(&self) -> Function {
        Function {
            f: ::core::clone::Clone::clone(&self.f),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            a: ::core::clone::Clone::clone(&self.a),
            b: ::core::clone::Clone::clone(&self.b),
            n: ::core::clone::Clone::clone(&self.n),
            k: ::core::clone::Clone::clone(&self.k),
        }
    }
}
impl Function {
    pub fn new(
        f: fn(f64) -> f64,
        i: &'static str,
        a: f64,
        b: f64,
        n: u8,
        k: u8,
    ) -> Self {
        Self {
            f: f,
            identifier: i,
            a: a,
            b: b,
            n: n,
            k: k,
        }
    }
}
fn right(f: &Function) -> f64 {
    let h: f64 = (f.b - f.a) / f.n as f64;
    let mut x = f.a + h;
    let mut sum: f64 = 0.0;
    while x <= f.b {
        sum += (f.f)(x);
        x += h;
    }
    sum * h
}
fn left(f: &Function) -> f64 {
    let h: f64 = (f.b - f.a) / f.n as f64;
    let mut x = f.a;
    let mut sum: f64 = 0.0;
    while x < f.b {
        sum += (f.f)(x);
        x += h;
    }
    sum * h
}
fn trapezoid(f: &Function) -> f64 {
    let h: f64 = (f.b - f.a) / f.n as f64;
    let mut x = f.a + h;
    let mut sum: f64 = ((f.f)(f.a) + (f.f)(f.b)) / 2.0;
    for _ in 1..f.n {
        sum += (f.f)(x);
        x += h;
    }
    sum * h
}
fn midpoint(f: &Function) -> f64 {
    let h: f64 = (f.b - f.a) / f.n as f64;
    let mut x = f.a + h * 0.5;
    let mut sum: f64 = 0.0;
    while x < f.b {
        sum += (f.f)(x);
        x += h;
    }
    sum * h
}
fn simpson(f: &Function) -> f64 {
    let h: f64 = (f.b - f.a) / f.n as f64;
    let mut x = f.a + h;
    let mut sum4: f64 = 0.0;
    for _ in 0..(f.n / 2) {
        sum4 += (f.f)(x);
        x += 2.0 * h;
    }
    let mut sum2: f64 = 0.0;
    x = f.a + 2.0 * h;
    for _ in 1..(f.n / 2) {
        sum2 += (f.f)(x);
        x += 2.0 * h;
    }
    (h / 3.0) * ((f.f)(f.a) + (f.f)(f.b) + 4.0 * sum4 + 2.0 * sum2)
}
fn romberg(f: &Function) -> Vec<Vec<f64>> {
    let mut r = ::alloc::vec::from_elem(Vec::<f64>::new(), f.k as usize);
    let h = (f.b - f.a) / f.n as f64;
    for i in 0..f.k {
        r[i as usize]
            .push(
                midpoint(
                    &Function {
                        n: f.n * i,
                        ..f.clone()
                    },
                ),
            );
    }
    r
}
fn main() {
    let ident: [Function; 4] = [
        Function::new(f, "4/(1+xˆ2)", 0.0, 1.0, 64, 4),
        Function::new(g, "xˆ4+xˆ2+1", -1.0, 1.0, 64, 4),
        Function::new(h, "exp(-xˆ2)", -2.5, 2.5, 128, 5),
        Function::new(j, "sin(xˆ2)", 0.0, std::f64::consts::PI.sqrt(), 64, 4),
    ];
    for i in ident {
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &[
                        "The left endpoint estimate for the Function f(x)=",
                        " on the interval [",
                        ",",
                        "] with n = ",
                        " is ",
                        ".\n",
                    ],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&i.identifier),
                        ::core::fmt::ArgumentV1::new_display(&i.a),
                        ::core::fmt::ArgumentV1::new_display(&i.b),
                        ::core::fmt::ArgumentV1::new_display(&i.n),
                        ::core::fmt::ArgumentV1::new_display(&left(&i)),
                    ],
                ),
            );
        };
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &[
                        "The right endpoint estimate for the Function f(x)=",
                        " on the interval [",
                        ",",
                        "] with n = ",
                        " is ",
                        ".\n",
                    ],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&i.identifier),
                        ::core::fmt::ArgumentV1::new_display(&i.a),
                        ::core::fmt::ArgumentV1::new_display(&i.b),
                        ::core::fmt::ArgumentV1::new_display(&i.n),
                        ::core::fmt::ArgumentV1::new_display(&right(&i)),
                    ],
                ),
            );
        };
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &[
                        "The trapezoid endpoint estimate for the Function f(x)=",
                        " on the interval [",
                        ",",
                        "] with n = ",
                        " is ",
                        ".\n",
                    ],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&i.identifier),
                        ::core::fmt::ArgumentV1::new_display(&i.a),
                        ::core::fmt::ArgumentV1::new_display(&i.b),
                        ::core::fmt::ArgumentV1::new_display(&i.n),
                        ::core::fmt::ArgumentV1::new_display(&trapezoid(&i)),
                    ],
                ),
            );
        };
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &[
                        "The midpoint endpoint estimate for the Function f(x)=",
                        " on the interval [",
                        ",",
                        "] with n = ",
                        " is ",
                        ".\n",
                    ],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&i.identifier),
                        ::core::fmt::ArgumentV1::new_display(&i.a),
                        ::core::fmt::ArgumentV1::new_display(&i.b),
                        ::core::fmt::ArgumentV1::new_display(&i.n),
                        ::core::fmt::ArgumentV1::new_display(&midpoint(&i)),
                    ],
                ),
            );
        };
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &[
                        "The Simpson\'s endpoint estimate for the Function f(x)=",
                        " on the interval [",
                        ",",
                        "] with n = ",
                        " is ",
                        ".\n",
                    ],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&i.identifier),
                        ::core::fmt::ArgumentV1::new_display(&i.a),
                        ::core::fmt::ArgumentV1::new_display(&i.b),
                        ::core::fmt::ArgumentV1::new_display(&i.n),
                        ::core::fmt::ArgumentV1::new_display(&simpson(&i)),
                    ],
                ),
            );
        };
        let r = romberg(&i);
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &[
                        "The Romberg algorithm estimate for the Function f(x)=",
                        " on the interval [",
                        ", ",
                        "] with k = ",
                        " is ",
                        ".\n\n",
                    ],
                    &[
                        ::core::fmt::ArgumentV1::new_display(&i.identifier),
                        ::core::fmt::ArgumentV1::new_display(&i.a),
                        ::core::fmt::ArgumentV1::new_display(&i.b),
                        ::core::fmt::ArgumentV1::new_display(&i.k),
                        ::core::fmt::ArgumentV1::new_display(
                            &r[i.k as usize - 1][i.k as usize - 1],
                        ),
                    ],
                ),
            );
        };
        {
            ::std::io::_print(
                ::core::fmt::Arguments::new_v1(
                    &["The Romberg matrix is:\n", "\n"],
                    &[::core::fmt::ArgumentV1::new_debug(&r)],
                ),
            );
        };
    }
}
